# Give your workflow a name (this appears in the GitHub Actions tab)
name: Easy CI

# Define when this workflow should run
## In this case, it runs on pushes to the main branch
on:
  push:
    branches: [ main ]

# Jobs are the main building blocks of a workflow
## Each job runs in a separate virtual machine
jobs:
  # This job is called "test" - for CI/CD, by convention, always call it test even though you can name it anything else
  test:
    # Specify which operating system to run on
    ## Other options: windows-latest, macos-latest
    ## We use ubuntu-latest because it is the most popular and easiest to use - GitHub Actions give us more free minutes wiht this option
    ## We also use this because Python packages are most compatible with Ubuntu
    runs-on: ubuntu-latest
    
    # Steps are the individual tasks that run in sequence
    steps:
    # Step 1: Download your code from the repository
    ## uses is a keyword that tells the workflow to use the action specified - in this case, we are using the checkout action to download our code from the repository
    ## actions/ are like libraries or packages from Python - sometimes they are official from GitHub, and sometimes they are from third parties (e.g., actions/setup-python is official from GitHub, while docker/xyz can be from third parties)
    ## checkout refers to downloading your code/files from the repo into a virtual machine that GitHub manages
    ##  The @v after the various actions you will see, like checkout and setup-python, ensure you get a specific, tested version rather than whatever is latest at runtime. This increases stability, reproducibilty and security
    - uses: actions/checkout@v4
    
    # Step 2: Set up Python
    ## This installs Python on the virtual machine
    ## names are labels for steps in the GitHub Actions UI - useful for debugging if something goes wrong

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.10"
    
    # Step 3: Install your project dependencies
    ## This reads requirements.txt and installs all the packages your project needs
    ## the | lets you write multiple lines of shell commands
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    # Step 4: Run a simple test
    ## This is where you actually test your code
    ## Our test: verify that key packages can be imported
    ## In a real project, you might run: pytest, unittest, or other test commands
    - name: Run tests
      run: |
        python -c "import numpy; import pandas; print('Basic imports successful!')"
